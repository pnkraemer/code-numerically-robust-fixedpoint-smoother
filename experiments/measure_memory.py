"""Measure the wall time of fixedpoint estimation via differnet methods."""import argparseimport osimport pickleimport jaximport jax.numpy as jnpfrom fpx import fpxdef main():    args = parse_args()    results = run_experiment(args)    dirname = str(__file__)    dirname = dirname.replace("experiments", "results")    dirname = dirname.replace(".py", "")    os.makedirs(dirname, exist_ok=True)    filename = f"{dirname}/results.pkl"    with open(filename, "wb") as f:        pickle.dump(results, f)    print(f"Saved results to {filename}.")def parse_args():    parser = argparse.ArgumentParser()    parser.add_argument("--seed", type=int, default=1)    return parser.parse_args()def run_experiment(args):    key = jax.random.PRNGKey(args.seed)    # It's all Cholesky-based for this experiment    impl = fpx.impl_cholesky_based()    results = {}    for num_steps in [1_000]:        label_num_steps = f"$K={num_steps}$"        results[label_num_steps] = {}        print(label_num_steps)        print("-" * len(label_num_steps))        for num_dims in [2, 5, 10, 20, 50, 100]:            label_num_dims = f"$d={num_dims}$"            results[label_num_steps][label_num_dims] = {}            print()            print(label_num_dims)            print("-" * len(label_num_dims))            # Set up an SSM            ts = jnp.linspace(0, 1, num=num_steps + 1)            ssm = fpx.ssm_car_tracking_velocity(                ts, noise=1.0, diffusion=1.0, impl=impl, dim=num_dims            )            sample = fpx.compute_stats_sample(impl=impl)            data = sample_data(key, ssm=ssm, sample=sample)            assert not jnp.any(jnp.isnan(data))            # Compute a reference solution            estimate = jax.jit(fpx.compute_fixedpoint(impl=impl))            ref, _ = estimate(data, ssm)            def callback(*x):                return {"size": jax.flatten_util.ravel_pytree(x)[0].size}            via_filter = fpx.compute_fixedpoint_via_filter(impl=impl, cb=callback)            via_fixedinterval = fpx.compute_fixedpoint_via_smoother(                impl=impl, cb=callback            )            via_recursion = fpx.compute_fixedpoint(impl=impl, cb=callback)            for name, estimate in [                ("Via recursion", via_recursion),                ("Via filter", via_filter),                ("Via fixed-interval", via_fixedinterval),            ]:                print(name)                _, aux = estimate(data, ssm=ssm)                # *32 for single-precision arithmetic, /8 for bit-to-byte                size_of = jnp.sum(aux["size"]) * (32 / 8)                print(f"\t {sizeof_fmt(size_of)}")                results[label_num_steps][label_num_dims][name] = jnp.sum(aux["size"])        print()    return resultsdef sizeof_fmt(num, suffix="B"):    for unit in ("", "Ki", "Mi", "Gi", "Ti", "Pi", "Ei", "Zi"):        if abs(num) < 1024.0:            return f"{num:3.3f} {unit}{suffix}"        num /= 1024.0    return f"{num:.1f}Yi{suffix}"def sample_data(key, *, ssm, sample):    (latent, data) = sample(key, ssm)    return datadef root_mean_square_error(a, b):    error_abs = jnp.abs(a - b)    return jnp.linalg.norm(error_abs / (1e-3 + jnp.abs(b))) / jnp.sqrt(b.size)if __name__ == "__main__":    main()