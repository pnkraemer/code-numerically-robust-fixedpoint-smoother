import jax.numpy as jnpimport jaximport osfrom fpx import fpximport picklejax.config.update("jax_enable_x64", True)# todo: interpolate sin(2*pi*t) on t in (0, 1) with a seven-derivative wiener process#  use square-root Kalman filter as gold standard#  compute deviations for cov-based and chol-based fixedpoint recursions#  in double precision for increasing resolution#  this should display stability?def main():    results = run_experiment()    dirname = str(__file__)    dirname = dirname.replace("experiments", "results")    dirname = dirname.replace(".py", "")    os.makedirs(dirname, exist_ok=True)    filename = f"{dirname}/results.pkl"    with open(filename, "wb") as f:        pickle.dump(results, f)    print(f"Saved results to {filename}.")def run_experiment():    results = {}    num_dims = 1    for num_steps in [2**i for i in range(1, 18, 1)]:        # Reference: Cholesky-based Kalman filter        impl = fpx.impl_cholesky_based()        ts = jnp.linspace(0, 1.0, num=num_steps + 1)        ssm = fpx.ssm_seventh_order_wiener_derivative(ts, impl=impl)        data = jnp.zeros((num_steps, num_dims))        estimate = jax.jit(fpx.compute_fixedpoint_via_filter(impl=impl))        reference, _ = estimate(data, ssm)        # reference = impl.rv_to_mvnorm(reference)        reference = reference.mean        reference = jax.flatten_util.ravel_pytree(reference)[0]        # Cholesky-based fixedpoint:        estimate = jax.jit(fpx.compute_fixedpoint(impl=impl))        result, _ = estimate(data, ssm)        # result = impl.rv_to_mvnorm(result)        result = result.mean        result = jax.flatten_util.ravel_pytree(result)[0]        print(            "cholesky",            num_steps,            "\n\t",            jnp.amax(jnp.abs(result - reference) / jnp.abs(reference)),        )        # Covariance-based fixedpoint:        impl = fpx.impl_covariance_based()        ts = jnp.linspace(0, 1.0, num=num_steps + 1)        ssm = fpx.ssm_seventh_order_wiener_derivative(ts, impl=impl)        estimate = jax.jit(fpx.compute_fixedpoint(impl=impl))        result, _ = estimate(data, ssm)        # result = impl.rv_to_mvnorm(result)        result = result.mean        result = jax.flatten_util.ravel_pytree(result)[0]        print(            "covariance",            num_steps,            "\n\t",            jnp.amax(jnp.abs(result - reference) / jnp.abs(reference)),        )        print()    return resultsdef sample_data(key, *, ssm, sample):    (latent, data) = sample(key, ssm)    return datadef root_mean_square_error(a, b):    error_abs = jnp.abs(a - b)    return jnp.linalg.norm(error_abs) / jnp.sqrt(b.size)if __name__ == "__main__":    main()